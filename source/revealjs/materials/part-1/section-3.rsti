.. Never add or change more than content, instead edit structure in files:
   ../part-X.rsti or ../../materials.rsti

Variant Management with Zephyr
==============================

Software Architecture
=====================

.. container:: flex-container

   .. container:: pct40
      
      .. image:: _images/sw-architecture.svg
         :width: 600

   .. container:: pct60

      * (mostly) straightforward mapping of already existing architecture to zephyr elements
      
        * services and module core logic become subsystems
        * re-use existing design patterns like :bash:`iterable sections` to implement custom extension points
        * **KConfig** for feature toggles
      
      * hardware abstraction via **device tree** took a couple of iterations, see next slides

Mapping the architecture to source code
---------------------------------------
      
.. container:: flex-container

   .. container:: pc50

      .. revealjs-code-block:: text

         subsys/
         ├── m_afe
         ├── m_heater
         │   ├── CMakeLists.txt
         │   ├── heater.c
         │   ├── heater_mqttrpc.c
         │   ├── heater_scope.c
         │   ├── heater_shell.c
         │   └── Kconfig
         ├── m_motor
         ├── s_datascope
         ├── s_mqtt_rpc
         ├── CMakeLists.txt
         ├── Kconfig
         └── Kconfig.template.subsystem
   
      .. literalinclude:: /samples/subsys/CMakeLists.txt

   .. container:: pct50

      .. literalinclude:: /samples/subsys/m_heater/Kconfig
      .. literalinclude:: /samples/subsys/Kconfig.template.subsystem 

Notes
-----

* map hardware modules to subsystems
* use Kconfig for feature toggles
* module bindings extend core services (shell, script engine, data scope, mqtt-rpc)

Device tree - Round 1
=====================


.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-1.svg
         :width: 900

   .. container:: pct40

      * trivial (and wrong) mapping
      * still good enough to make a start 
      * bind subsystems only via :bash:`"aliases"`, :bash:`"zephyr,user"`, :bash:`"dt,chosen"`


.. revealjs-code-block:: bash

   west build -b devrig ...

Reality Check
=============

|nbsp|

System testing showed that motor was not strong enough, needed bigger motor (and driver). Also, a couple of 
other findings ...

The peripherals board revision 2 was coming ...

Device tree - Round 2
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-2.svg
         :width: 900

   .. container:: pct40

      * trivial approach leads to duplicates once hardware revisions enter the stage
      * **shields** provide a decent abstraction to map 1:1 actual hardware entities (boards) to software entities (board, shields)
      * in addition shields can have board specific overlays
      
        * this is how we actually refactored :bash:`devrig` into :bash:`core` and :bash:`peripherals`
        * introducing new hardware revisions for peripherals board now boils down to adding new overlays


.. revealjs-code-block:: bash

   west build -b core ... -- -DSHIELDS="peripherals_v1"
   west build -b core ... -- -DSHIELDS="peripherals_v2"


Reality Check
=============

|nbsp|

We needed to build 200 additional rigs for lab testing but couldn't even build another 5 core boards due to
supply shortage. 

Well, we couldn't buy STM32F7 chips, but we could still buy *Nucleo-F767* boards :-)

Now the question becomes: How can we model rigs with *Nucleo* rather than core boards?

Device tree - Round 3
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-3.svg
         :width: 900

   .. container:: pct40

      * shields of previous step still tightly coupled to underlying core board
      * still missing another abstraction from the hardware model -- **peripherals connector**
      * followed what exists for *Arduino* connector in many boards
      * shields now depend on an abstraction, not underlying board details

.. revealjs-code-block:: bash

   west build -b core ... -- -DSHIELDS="peripherals_v1"
   west build -b core ... -- -DSHIELDS="peripherals_v2"


Device tree - Round 4
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-4.svg
         :width: 900

   .. container:: pct40

      * needed another 'routing' board to map *Nucleo* connectors (st-morpho) to peripherals board connector
      * motivates new shield :bash:`x_nucleo_nexus`
      
        * needs to realize peripherals connector interface :bash:`prph_IF` similar to core board
        * implement bindings in terms of another abstraction for the st-morpho connector :bash:`morpho_IF`  
        * create a virtual shield :bash:`x_nucleo_144` to "inject" :bash:`morpho_IF` into board device tree


.. revealjs-code-block:: bash

   west build -b core          ... -- -DSHIELDS="peripherals_v1"
   west build -b core          ... -- -DSHIELDS="peripherals_v2"
   
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v2"


Reality Check
=============

|nbsp|

Turns out we can't get enough Nucleo-F767 either. 

But didn't you say, one Nucleo-144 is a good as any other? 

So, what about Nucleo-H743 and Nucleo-H745?


What did we achieve?
====================

.. container:: flex-container

   .. container:: pct40

      * 1:1 mapping between hardware and software (device tree)
      * no schematic details exposed to source code
      * can build SW for 8 different HW configuration not touching a single line of code
      * system-level configurations map transparently to SW build system
      * open/closed principle fully realized


   .. container:: pct60

      .. imagesvg:: _images/devrig-variants.svg
         :tagtype: object
         :width: 650

.. revealjs-code-block:: bash

   west build -b core          ... -- -DSHIELDS="peripherals_v1"
  
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"

   west build -b nucleo_h743zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"


The moment of true love
=======================

.. revealjs-fragments:: 

   .. container:: flex-container
   
      .. container:: 50pct 
   
         .. image:: _images/full-rig.svg
            :width: 1000
   
      .. container:: 50pct
   
         * reality knocked at our door once more ...
         * connection between application controller and realtime controller based on private Ethernet link 
         * original application control impossible to make, too 
           
           * featured two distinct Ethernet interfaces
     
         * Raspberry Pi 4 as substitute
         
           * features only one Ethernet link 
   
   .. container:: flex-container
   
      .. container:: 50pct 
   
         .. revealjs-code-block:: kconfig
         
            # overlay netusb.conf
            # Enable USB device stack
            CONFIG_USB_DEVICE_STACK=y
            
            # Select USB network device class (CDC-ECM)
            CONFIG_USB_DEVICE_NETWORK_ECM=y
            CONFIG_NET_CONFIG_NEED_IPV4=n
   
         .. revealjs-code-block:: bash
   
            west build -b nucleo_f767zi -- -DSHIELDS="..." -DOVERLAY_CONF="netusb.conf"
   
      .. container:: 50pct
   
         * Zephyr (and Yocto Linux) had all on board to switch to Ethernet over USB with a few lines of additional configuration code
         * All upper layers (TCP - MQTT - MQTT-RPC - Application) worked right away
   
   Most embedded developers we have worked with wouldn't believe this is possible




.. Local variables:
   coding: utf-8
   mode: text
   mode: rst
   End:
   vim: fileencoding=utf-8 filetype=rst number :
