.. Never add or change more than content, instead edit structure in files:
   ../part-X.rsti or ../../materials.rsti

Variant Management with Zephyr
==============================

Software Architecture
=====================

.. container:: flex-container

   .. container:: pct40
      
      .. image:: _images/sw-architecture.svg
         :width: 600

   .. container:: pct60

      * (mostly) straightforward mapping of already existing architecture to zephyr elements
      
        * services and module core logic become subsystems
        * re-use existing design patterns like :bash:`iterable sections` to implement custom extension points
        * **KConfig** for feature toogles
      
      * hardware abstraction via **device tree** took a couple of iterations, see next slides
  


Notes
-----

* map hw-module to subsystem
* use kconfig for feature toggles
* module bindings extend core services (shell, script engine, data scope, mqtt-rpc)

Device tree - Round 1
=====================


.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-1.svg
         :width: 900

   .. container:: pct40

      * trivial (and wrong) mapping
      * still good enough to make a start 
      * bind subsystems only via :bash:`"aliases"`, :bash:`"zephyr,user"`, :bash:`"dt,chosen"`


.. revealjs-code-block:: bash

   west build -b devrig ...

Reality Check
=============

System testing showed that motor was not strong enough, needed bigger motor (and driver). Also, a couple of 
other findings ...

The peripherals board revision 2 was coming ...

Device tree - Round 2
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-2.svg
         :width: 900

   .. container:: pct40

      * trivial approach leads to duplicates once hardware revisions enter the stage
      * **shields** provide a decent abstraction to map 1:1 actual hw entities (boards) to sw entities (board, shields)
      * in addition shields can have board specific overlays
      
        * this is how we actually refactored :bash:`devrig` into :bash:`core` and :bash:`peripherals`
        * introducing new hw revision for peripherals board now boils down to adding new overlays


.. revealjs-code-block:: bash

   west build -b core ... -- -DSHIELDS="peripherals_v1"
   west build -b core ... -- -DSHIELDS="peripherals_v2"


Reality Check
=============

We needed to build 200 additional rigs for lab testing but couldn't even build another 5 core boards due to
supply shortage. 

Well, we couldn't buy STM32F7 chips, but we could still buy *Nucleo-F767* boards :-)

Now the question becomes: How can we model rigs with *Nucleo* rather than core boards?

Device tree - Round 3
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-3.svg
         :width: 900

   .. container:: pct40

      * shields of previous step still tightly coupled to underlying core board
      * still missing another abstraction from the hw model -- **peripherals connector**
      * followed what exists for arduino connector in many boards
      * shields now depend on an abstraction, not underlying board details

.. revealjs-code-block:: bash

   west build -b core ... -- -DSHIELDS="peripherals_v1"
   west build -b core ... -- -DSHIELDS="peripherals_v2"


Device tree - Round 4
=====================

.. container:: flex-container

   .. container:: pct60

      .. image:: _images/hw-sw-domains.svg
         :width: 900
      
      
      .. image:: _images/devicetree-4.svg
         :width: 900

   .. container:: pct40

      * needed another 'routing' board to map nucleo connectors (st-morpho) to peripherals board connector
      * motivates new shield :bash:`x_nucleo_nexus`
      
        * needs to realize peripherals connector interface :bash:`prph_IF` similar to core board
        * implement bindings in terms of another abstraction for the st-morpho connector :bash:`morpho_IF`  
        * create a virtual shield :bash:`x_nucleo_144` to "inject" :bash:`morpho_IF` into board device tree


.. revealjs-code-block:: bash

   west build -b core          ... -- -DSHIELDS="peripherals_v1"
   west build -b core          ... -- -DSHIELDS="peripherals_v2"
   
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v2"


Reality Check
=============

Turns out we can't get enough Nucleo-F767 either. 

But didn't you say, one Nucleo-144 is a good as any other? 

So, what about Nucleo-H743 and Nucleo-H745?


What did we achieve?
====================

.. container:: flex-container

   .. container:: pct40

      * 1:1 mapping between hardware and software (device tree)
      * no schematic details exposed to source code
      * can build SW for 8 different HW configuration not touching a single line of code
      * system-level configurations map transparently to SW build system
      * open/closed principle fully realised


   .. container:: pct60

      .. imagesvg:: _images/devrig-variants.svg
         :tagtype: object
         :width: 800

.. revealjs-code-block:: bash

   west build -b core          ... -- -DSHIELDS="peripherals_v1"
  
   west build -b nucleo_f767zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"

   west build -b nucleo_h743zi ... -- -DSHIELDS="x_nucleo_144; x_nucleo_nexus; peripherals_v1"


The moment of true love
=======================

.. revealjs-fragments:: 

   .. container:: flex-container
   
      .. container:: 50pct 
   
         .. image:: _images/full-rig.svg
            :width: 1000
   
      .. container:: 50pct
   
         * reality knocked at our door once more ...
         * connection between application controller and realtime controller based on private ethernet link 
         * original application control impossible to make, too 
           
           * featured two distinct ethernet interfaces
     
         * RPi4 as substitute
         
           * features only one ethernet link 
   
   .. container:: flex-container
   
      .. container:: 50pct 
   
         .. revealjs-code-block:: kconfig
         
            # overlay netusb.conf
            # Enable USB device stack
            CONFIG_USB_DEVICE_STACK=y
            
            # Select USB network device class (CDC-ECM)
            CONFIG_USB_DEVICE_NETWORK_ECM=y
            CONFIG_NET_CONFIG_NEED_IPV4=n
   
         .. revealjs-code-block:: bash
   
            west build -b nucleo_f767zi ... -- -DSHIELDS="..." -DOVERLAY_CONF="netusb.conf"
   
      .. container:: 50pct
   
         * Zephyr (and Yocto Linux) had all on board to switch to ethernet over USB with a few lines of additional configuration code
         * All upper layers (TCP - MQTT - MQTT-RPC - Application) worked right away
   
   Most embedded developers we have worked with wouldn't believe this is possible


Sharing design patterns with the community
==========================================

.. container:: flex-container

   .. container:: 40pct

      .. image:: _images/bridle-grove-kits.svg
         :width: 600

   .. container:: 60pct

      * Design patterns re-implemented using publicly available boards as part of the `Bridle project <https://bridle.tiac-systems.net/doc/latest/bridle/index.html>`_
      * `Grove system <https://wiki.seeedstudio.com/Grove_System/>`_ has tons of modules, relatively low-cost 
      * Further development in the open, contributions welcome
      * Engage with Zephyr community to upstream relevant pieces 

Examples 
--------

.. container:: flex-container

   .. container:: 50pct

      .. image:: https://bridle.tiac-systems.net/doc/latest/bridle/_images/x_grove_testbed_stmb1137_bb.svg


   .. container:: 50pct

      .. image:: https://bridle.tiac-systems.net/doc/latest/bridle/_images/x_grove_testbed_rpi_pico_bb.svg


.. revealjs-code-block:: bash

   # for left configuration
   west build -b nucleo_f767zi ...blinky -- -DSHIELD="seeed_grove_base_v2 grove_btn_d4 grove_led_d6 grove_pwm_led_d6 x_grove_testbed"
   
   # for right configuration
   west build -b rpi_pico ...blinky      -- -DSHIELD="seeed_grove_rpipico_v1 grove_btn_d16 grove_led_d18 grove_pwm_led_d18 x_grove_testbed"

See `Bridle documentation <https://bridle.tiac-systems.net/doc/latest/bridle/boards/shields/x_grove_testbed/doc/index.html#build-and-programming>`_ for more details


.. Local variables:
   coding: utf-8
   mode: text
   mode: rst
   End:
   vim: fileencoding=utf-8 filetype=rst number :
